"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./context/Voters.js":
/*!***************************!*\
  !*** ./context/Voters.js ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VotingContext\": function() { return /* binding */ VotingContext; },\n/* harmony export */   \"VotingProvider\": function() { return /* binding */ VotingProvider; },\n/* harmony export */   \"fetchContract\": function() { return /* binding */ fetchContract; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var web3modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! web3modal */ \"./node_modules/web3modal/dist/index.js\");\n/* harmony import */ var web3modal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(web3modal__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ \"./context/constants.js\");\n/* harmony import */ var _pinata__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pinata */ \"./context/pinata.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils */ \"./context/utils.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n// import cv from \"@techstark/opencv-js\";\n// Define a function to load and process an image\n// function loadImageAndProcess(fileURL) {\n// Load the image from the fileURL and convert to grayscale\n//\n// console.log(fileURL);\n// let img = cv.imread(fileURL);\n// cv.imread(fileURL);\n// let gray_img = new cv.Mat();\n// cv.cvtColor(img, gray_img, cv.COLOR_BGR2GRAY);\n// // Create a SIFT object and detect keypoints and descriptors\n// let sift = new cv.SIFT();\n// let kp_img = new cv.KeyPointVector();\n// let des_img = new cv.Mat();\n// sift.detectAndCompute(gray_img, new cv.Mat(), kp_img, des_img);\n// // Return the image, keypoints, and descriptors\n// return [img, kp_img, des_img];\n// }\n// Define a function to verify the face using SIFT features\n// function verifyFace(fileURL, threshold) {\n// Load and process the image from the fileURL\n// let cap = new cv.VideoCapture(0);\n// loadImageAndProcess(fileURL);\n// let [img, kp_img, des_img] = loadImageAndProcess(fileURL);\n// console.log(img);\n// // Open the camera and capture a frame\n// let cap = new cv.VideoCapture(0);\n// let frame = new cv.Mat();\n// cap.read(frame);\n// // Convert the frame to grayscale and detect keypoints and descriptors\n// let gray_frame = new cv.Mat();\n// cv.cvtColor(frame, gray_frame, cv.COLOR_BGR2GRAY);\n// let kp_frame = new cv.KeyPointVector();\n// let des_frame = new cv.Mat();\n// sift.detectAndCompute(gray_frame, new cv.Mat(), kp_frame, des_frame);\n// // Match the descriptors using Brute Force Matcher and sort by distance\n// let bf = new cv.BFMatcher(cv.NORM_L1, true);\n// let matches = new cv.DMatchVector();\n// bf.match(des_img, des_frame, matches);\n// matches.sort((a, b) => a.distance - b.distance);\n// // Draw the matched keypoints and display the result\n// let matching_result = new cv.Mat();\n// cv.drawMatches(img, kp_img, frame, kp_frame, matches, matching_result);\n// cv.imshow(\"Matching Result\", matching_result);\n// // Calculate the ratio of matches to keypoints and compare with threshold\n// let ratio = matches.size() / kp_img.size();\n// if (ratio >= threshold) {\n//   console.log(\"Face verified\");\n// } else {\n//   console.log(\"Face not verified\");\n// }\n// // Release the camera and close the windows\n// cap.release();\n// cv.destroyAllWindows();\n// }\n// verifyFace(\"https://ipfs.io/ipfs/QmQCutTj8gCnHfQ64mBcRu1b2DAuxgKXYoUrgwmJPhXkvB\", 0.7);\nconst fetchContract = (signerOrProvider)=>new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Contract(_constants__WEBPACK_IMPORTED_MODULE_4__.VotingAddress, _constants__WEBPACK_IMPORTED_MODULE_4__.VotingAddressABI, signerOrProvider);\nconst VotingContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createContext();\nconst VotingProvider = (param)=>{\n    let { children  } = param;\n    _s();\n    const votingTitle = \"Voting contract\";\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_3__.useRouter)();\n    let vlen = 0;\n    let clen = 0;\n    let ca = \"\";\n    const [currentAccount, setCurrentAccount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(ca);\n    const [candidateLength, setCandidateLength] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(clen);\n    const pushCandidate = [];\n    const candidateIndex = [];\n    const [candidateArray, setCandidateArray] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(pushCandidate);\n    const [error, SetError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const highestVote = [];\n    const pushVoters = [];\n    const [voterArray, setVoterArray] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(pushVoters);\n    const [voterLength, setVoterLength] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(vlen);\n    const [voterAddress, setVoterAddress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [fileURL, setFileURL] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // connecting wallet\n    const checkIfWalletIsConnected = async ()=>{\n        if (!window.ethereum) return SetError(\"please install metamask\");\n        const account = await window.ethereum.request({\n            method: \"eth_accounts\"\n        });\n        if (account.length) {\n            setCurrentAccount(account[0]);\n            console.log(currentAccount);\n        } else {\n            SetError(\"please install metamask & Reload\");\n        }\n    };\n    // connect wallet\n    const connectWallet = async ()=>{\n        if (!window.ethereum) return SetError(\"please install metamask\");\n        const account = await window.ethereum.request({\n            method: \"eth_requestAccounts\"\n        });\n        setCurrentAccount(account[0]);\n    };\n    //create voters\n    const createVoter = async (formInput, fileURL, router)=>{\n        try {\n            const { name , address , position , pin  } = formInput;\n            if (!name || !address || !position || !pin) {\n                SetError(\"Input data is missing\");\n            }\n            //connecting smart contract\n            const web3modal = new (web3modal__WEBPACK_IMPORTED_MODULE_2___default())();\n            const connection = await web3modal.connect();\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.providers.Web3Provider(connection);\n            const signer = provider.getSigner();\n            const contract = fetchContract(signer);\n            const data = {\n                name,\n                address,\n                position,\n                image: fileURL\n            };\n            const pinataUrl = await (0,_pinata__WEBPACK_IMPORTED_MODULE_5__.uploadJSONToIPFS)(data);\n            const ipfsUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_6__.GetIpfsUrlFromPinata)(pinataUrl.pinataURL);\n            const voter = await contract.voterRight(address, name, fileURL, ipfsUrl);\n            await voter.wait();\n            let result = await fetch(\"http://localhost:3001/add-pin\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    address,\n                    pin\n                }),\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n            result = result.json();\n            console(result);\n            if (result) {\n                router.push(\"/voterList\");\n            }\n            console.log(voter);\n            router.push(\"/voterList\");\n        } catch (error) {\n            SetError(\"Error in creating the voter\");\n        }\n    };\n    const getAllVoterData = async ()=>{\n        try {\n            const web3modal = new (web3modal__WEBPACK_IMPORTED_MODULE_2___default())();\n            const connection = await web3modal.connect();\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.providers.Web3Provider(connection);\n            const signer = provider.getSigner();\n            const contract = fetchContract(signer);\n            const voterListData = await contract.getVoterList();\n            setVoterAddress(voterListData);\n            voterListData.map(async (el)=>{\n                const singleVoterData = await contract.getVoterData(el);\n                pushVoters.push(singleVoterData);\n            });\n            const voterList = await contract.getVoterLength();\n            // console.log(voterList.toNumber());\n            vlen = voterList.toNumber();\n            // console.log(vlen);\n            setVoterLength(vlen);\n            // setVoterLength(voterList.toNumber());\n            console.log(voterLength);\n        } catch (error) {\n            SetError(\"Something went wrong in fetching voter\");\n        }\n    };\n    const setCandidate = async (candidateForm, fileURL, router)=>{\n        try {\n            const { name , address , age  } = candidateForm;\n            if (!name || !address || !age) {\n                SetError(\"Input data is missing\");\n            }\n            console.log(name, address, age, fileURL);\n            const web3modal = new (web3modal__WEBPACK_IMPORTED_MODULE_2___default())();\n            const connection = await web3modal.connect();\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.providers.Web3Provider(connection);\n            const signer = provider.getSigner();\n            const contract = fetchContract(signer);\n            const data = {\n                name,\n                address,\n                age,\n                image: fileURL\n            };\n            const pinataUrl = await (0,_pinata__WEBPACK_IMPORTED_MODULE_5__.uploadJSONToIPFS)(data);\n            const ipfsUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_6__.GetIpfsUrlFromPinata)(pinataUrl.pinataURL);\n            const candidate = await contract.setCandidate(address, age, name, fileURL, ipfsUrl);\n            await candidate.wait();\n            // verifyFace(fileURL, 0.7);\n            console.log(candidate);\n            router.push(\"/\");\n        } catch (error) {\n            console.log(error);\n        }\n    };\n    const getNewCandidate = async ()=>{\n        try {\n            const web3modal = new (web3modal__WEBPACK_IMPORTED_MODULE_2___default())();\n            const connection = await web3modal.connect();\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.providers.Web3Provider(connection);\n            const signer = provider.getSigner();\n            const contract = fetchContract(signer);\n            console.log(contract);\n            try {\n                console.log(await contract.getCandidates());\n            } catch (error) {\n                console.log(error);\n            }\n            const allCandidates = await contract.getCandidates();\n            // console.log(allCandidates);\n            allCandidates.map(async (ele)=>{\n                const singleCandidate = await contract.getCandidateData(ele);\n                pushCandidate.push(singleCandidate);\n                candidateIndex.push(singleCandidate[2].toNumber());\n            });\n            console.log(pushCandidate);\n            // console.log(currentAccount);\n            const allCandidatesLength = await contract.getCandidateLength();\n            clen = allCandidatesLength.toNumber();\n            setCandidateLength(clen);\n        } catch (error) {\n            SetError(\"Something went wrong in fetching candidate\");\n        }\n    };\n    // useEffect(() => {\n    //   getNewCandidate();\n    // }, []);\n    //upload to ipfs voter image\n    const giveVote = async (id)=>{\n        try {\n            const candidateAddress = id.address;\n            const candidateId = id.id;\n            const web3modal = new (web3modal__WEBPACK_IMPORTED_MODULE_2___default())();\n            const connection = await web3modal.connect();\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.providers.Web3Provider(connection);\n            const signer = provider.getSigner();\n            const contract = fetchContract(signer);\n            const voteredList = await contract.vote(candidateAddress, candidateId);\n            console.log(voteredList);\n        } catch (error) {\n            console.log(error);\n            SetError(\"Error in giving vote\");\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(VotingContext.Provider, {\n        value: {\n            votingTitle,\n            checkIfWalletIsConnected,\n            connectWallet,\n            createVoter,\n            getAllVoterData,\n            giveVote,\n            setCandidate,\n            getNewCandidate,\n            error,\n            voterArray,\n            voterLength,\n            voterAddress,\n            currentAccount,\n            candidateLength,\n            candidateArray\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Shrutayu Aggarwal\\\\VotingDapp\\\\context\\\\Voters.js\",\n        lineNumber: 294,\n        columnNumber: 5\n    }, undefined);\n};\n_s(VotingProvider, \"IZpaZmyYqirwyvZ8xHbgAj6kYaU=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_3__.useRouter\n    ];\n});\n_c = VotingProvider;\nvar _c;\n$RefreshReg$(_c, \"VotingProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFDWkMsU0FBUztRQUNYO0lBQ0Y7SUFDQSxxQkFDRSw4REFBQ2xCLGNBQWNrRyxRQUFRO1FBQ3JCQyxPQUFPO1lBQ0wvRjtZQUNBeUI7WUFDQVM7WUFDQUM7WUFDQStCO1lBQ0FzQjtZQUNBWjtZQUNBSTtZQUNBbkU7WUFDQUk7WUFDQUU7WUFDQUU7WUFDQWhCO1lBQ0FFO1lBQ0FJO1FBQ0Y7a0JBRUNaOzs7Ozs7QUFHUCxFQUFFO0dBek9XRDs7UUFFSVgsa0RBQVNBOzs7S0FGYlciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGV4dC9Wb3RlcnMuanM/MmU1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgV2ViM01vZGFsIGZyb20gXCJ3ZWIzbW9kYWxcIjtcclxuaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSBcImV0aGVyc1wiO1xyXG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L3JvdXRlclwiO1xyXG5cclxuaW1wb3J0IHsgVm90aW5nQWRkcmVzcywgVm90aW5nQWRkcmVzc0FCSSB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xyXG5pbXBvcnQgeyB1cGxvYWRGaWxlVG9JUEZTLCB1cGxvYWRKU09OVG9JUEZTIH0gZnJvbSBcIi4vcGluYXRhXCI7XHJcbmltcG9ydCB7IEdldElwZnNVcmxGcm9tUGluYXRhIH0gZnJvbSBcIi4vdXRpbHNcIjtcclxuXHJcbi8vIGltcG9ydCBjdiBmcm9tIFwiQHRlY2hzdGFyay9vcGVuY3YtanNcIjtcclxuXHJcbi8vIERlZmluZSBhIGZ1bmN0aW9uIHRvIGxvYWQgYW5kIHByb2Nlc3MgYW4gaW1hZ2VcclxuLy8gZnVuY3Rpb24gbG9hZEltYWdlQW5kUHJvY2VzcyhmaWxlVVJMKSB7XHJcbi8vIExvYWQgdGhlIGltYWdlIGZyb20gdGhlIGZpbGVVUkwgYW5kIGNvbnZlcnQgdG8gZ3JheXNjYWxlXHJcbi8vXHJcbi8vIGNvbnNvbGUubG9nKGZpbGVVUkwpO1xyXG4vLyBsZXQgaW1nID0gY3YuaW1yZWFkKGZpbGVVUkwpO1xyXG4vLyBjdi5pbXJlYWQoZmlsZVVSTCk7XHJcbi8vIGxldCBncmF5X2ltZyA9IG5ldyBjdi5NYXQoKTtcclxuLy8gY3YuY3Z0Q29sb3IoaW1nLCBncmF5X2ltZywgY3YuQ09MT1JfQkdSMkdSQVkpO1xyXG5cclxuLy8gLy8gQ3JlYXRlIGEgU0lGVCBvYmplY3QgYW5kIGRldGVjdCBrZXlwb2ludHMgYW5kIGRlc2NyaXB0b3JzXHJcbi8vIGxldCBzaWZ0ID0gbmV3IGN2LlNJRlQoKTtcclxuLy8gbGV0IGtwX2ltZyA9IG5ldyBjdi5LZXlQb2ludFZlY3RvcigpO1xyXG4vLyBsZXQgZGVzX2ltZyA9IG5ldyBjdi5NYXQoKTtcclxuLy8gc2lmdC5kZXRlY3RBbmRDb21wdXRlKGdyYXlfaW1nLCBuZXcgY3YuTWF0KCksIGtwX2ltZywgZGVzX2ltZyk7XHJcblxyXG4vLyAvLyBSZXR1cm4gdGhlIGltYWdlLCBrZXlwb2ludHMsIGFuZCBkZXNjcmlwdG9yc1xyXG4vLyByZXR1cm4gW2ltZywga3BfaW1nLCBkZXNfaW1nXTtcclxuLy8gfVxyXG5cclxuLy8gRGVmaW5lIGEgZnVuY3Rpb24gdG8gdmVyaWZ5IHRoZSBmYWNlIHVzaW5nIFNJRlQgZmVhdHVyZXNcclxuLy8gZnVuY3Rpb24gdmVyaWZ5RmFjZShmaWxlVVJMLCB0aHJlc2hvbGQpIHtcclxuLy8gTG9hZCBhbmQgcHJvY2VzcyB0aGUgaW1hZ2UgZnJvbSB0aGUgZmlsZVVSTFxyXG4vLyBsZXQgY2FwID0gbmV3IGN2LlZpZGVvQ2FwdHVyZSgwKTtcclxuLy8gbG9hZEltYWdlQW5kUHJvY2VzcyhmaWxlVVJMKTtcclxuLy8gbGV0IFtpbWcsIGtwX2ltZywgZGVzX2ltZ10gPSBsb2FkSW1hZ2VBbmRQcm9jZXNzKGZpbGVVUkwpO1xyXG4vLyBjb25zb2xlLmxvZyhpbWcpO1xyXG5cclxuLy8gLy8gT3BlbiB0aGUgY2FtZXJhIGFuZCBjYXB0dXJlIGEgZnJhbWVcclxuLy8gbGV0IGNhcCA9IG5ldyBjdi5WaWRlb0NhcHR1cmUoMCk7XHJcbi8vIGxldCBmcmFtZSA9IG5ldyBjdi5NYXQoKTtcclxuLy8gY2FwLnJlYWQoZnJhbWUpO1xyXG5cclxuLy8gLy8gQ29udmVydCB0aGUgZnJhbWUgdG8gZ3JheXNjYWxlIGFuZCBkZXRlY3Qga2V5cG9pbnRzIGFuZCBkZXNjcmlwdG9yc1xyXG4vLyBsZXQgZ3JheV9mcmFtZSA9IG5ldyBjdi5NYXQoKTtcclxuLy8gY3YuY3Z0Q29sb3IoZnJhbWUsIGdyYXlfZnJhbWUsIGN2LkNPTE9SX0JHUjJHUkFZKTtcclxuLy8gbGV0IGtwX2ZyYW1lID0gbmV3IGN2LktleVBvaW50VmVjdG9yKCk7XHJcbi8vIGxldCBkZXNfZnJhbWUgPSBuZXcgY3YuTWF0KCk7XHJcbi8vIHNpZnQuZGV0ZWN0QW5kQ29tcHV0ZShncmF5X2ZyYW1lLCBuZXcgY3YuTWF0KCksIGtwX2ZyYW1lLCBkZXNfZnJhbWUpO1xyXG5cclxuLy8gLy8gTWF0Y2ggdGhlIGRlc2NyaXB0b3JzIHVzaW5nIEJydXRlIEZvcmNlIE1hdGNoZXIgYW5kIHNvcnQgYnkgZGlzdGFuY2VcclxuLy8gbGV0IGJmID0gbmV3IGN2LkJGTWF0Y2hlcihjdi5OT1JNX0wxLCB0cnVlKTtcclxuLy8gbGV0IG1hdGNoZXMgPSBuZXcgY3YuRE1hdGNoVmVjdG9yKCk7XHJcbi8vIGJmLm1hdGNoKGRlc19pbWcsIGRlc19mcmFtZSwgbWF0Y2hlcyk7XHJcbi8vIG1hdGNoZXMuc29ydCgoYSwgYikgPT4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2UpO1xyXG5cclxuLy8gLy8gRHJhdyB0aGUgbWF0Y2hlZCBrZXlwb2ludHMgYW5kIGRpc3BsYXkgdGhlIHJlc3VsdFxyXG4vLyBsZXQgbWF0Y2hpbmdfcmVzdWx0ID0gbmV3IGN2Lk1hdCgpO1xyXG4vLyBjdi5kcmF3TWF0Y2hlcyhpbWcsIGtwX2ltZywgZnJhbWUsIGtwX2ZyYW1lLCBtYXRjaGVzLCBtYXRjaGluZ19yZXN1bHQpO1xyXG4vLyBjdi5pbXNob3coXCJNYXRjaGluZyBSZXN1bHRcIiwgbWF0Y2hpbmdfcmVzdWx0KTtcclxuXHJcbi8vIC8vIENhbGN1bGF0ZSB0aGUgcmF0aW8gb2YgbWF0Y2hlcyB0byBrZXlwb2ludHMgYW5kIGNvbXBhcmUgd2l0aCB0aHJlc2hvbGRcclxuLy8gbGV0IHJhdGlvID0gbWF0Y2hlcy5zaXplKCkgLyBrcF9pbWcuc2l6ZSgpO1xyXG4vLyBpZiAocmF0aW8gPj0gdGhyZXNob2xkKSB7XHJcbi8vICAgY29uc29sZS5sb2coXCJGYWNlIHZlcmlmaWVkXCIpO1xyXG4vLyB9IGVsc2Uge1xyXG4vLyAgIGNvbnNvbGUubG9nKFwiRmFjZSBub3QgdmVyaWZpZWRcIik7XHJcbi8vIH1cclxuXHJcbi8vIC8vIFJlbGVhc2UgdGhlIGNhbWVyYSBhbmQgY2xvc2UgdGhlIHdpbmRvd3NcclxuLy8gY2FwLnJlbGVhc2UoKTtcclxuLy8gY3YuZGVzdHJveUFsbFdpbmRvd3MoKTtcclxuLy8gfVxyXG5cclxuLy8gdmVyaWZ5RmFjZShcImh0dHBzOi8vaXBmcy5pby9pcGZzL1FtUUN1dFRqOGdDbkhmUTY0bUJjUnUxYjJEQXV4Z0tYWW9Vcmd3bUpQaFhrdkJcIiwgMC43KTtcclxuXHJcbmV4cG9ydCBjb25zdCBmZXRjaENvbnRyYWN0ID0gKHNpZ25lck9yUHJvdmlkZXIpID0+XHJcbiAgbmV3IGV0aGVycy5Db250cmFjdChWb3RpbmdBZGRyZXNzLCBWb3RpbmdBZGRyZXNzQUJJLCBzaWduZXJPclByb3ZpZGVyKTtcclxuXHJcbmV4cG9ydCBjb25zdCBWb3RpbmdDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCgpO1xyXG5leHBvcnQgY29uc3QgVm90aW5nUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgY29uc3Qgdm90aW5nVGl0bGUgPSBcIlZvdGluZyBjb250cmFjdFwiO1xyXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xyXG4gIGxldCB2bGVuID0gMDtcclxuICBsZXQgY2xlbiA9IDA7XHJcbiAgbGV0IGNhID0gXCJcIjtcclxuICBjb25zdCBbY3VycmVudEFjY291bnQsIHNldEN1cnJlbnRBY2NvdW50XSA9IHVzZVN0YXRlKGNhKTtcclxuICBjb25zdCBbY2FuZGlkYXRlTGVuZ3RoLCBzZXRDYW5kaWRhdGVMZW5ndGhdID0gdXNlU3RhdGUoY2xlbik7XHJcbiAgY29uc3QgcHVzaENhbmRpZGF0ZSA9IFtdO1xyXG4gIGNvbnN0IGNhbmRpZGF0ZUluZGV4ID0gW107XHJcbiAgY29uc3QgW2NhbmRpZGF0ZUFycmF5LCBzZXRDYW5kaWRhdGVBcnJheV0gPSB1c2VTdGF0ZShwdXNoQ2FuZGlkYXRlKTtcclxuXHJcbiAgY29uc3QgW2Vycm9yLCBTZXRFcnJvcl0gPSB1c2VTdGF0ZShcIlwiKTtcclxuICBjb25zdCBoaWdoZXN0Vm90ZSA9IFtdO1xyXG5cclxuICBjb25zdCBwdXNoVm90ZXJzID0gW107XHJcbiAgY29uc3QgW3ZvdGVyQXJyYXksIHNldFZvdGVyQXJyYXldID0gdXNlU3RhdGUocHVzaFZvdGVycyk7XHJcbiAgY29uc3QgW3ZvdGVyTGVuZ3RoLCBzZXRWb3Rlckxlbmd0aF0gPSB1c2VTdGF0ZSh2bGVuKTtcclxuICBjb25zdCBbdm90ZXJBZGRyZXNzLCBzZXRWb3RlckFkZHJlc3NdID0gdXNlU3RhdGUoW10pO1xyXG4gIGNvbnN0IFtmaWxlVVJMLCBzZXRGaWxlVVJMXSA9IHVzZVN0YXRlKG51bGwpO1xyXG5cclxuICAvLyBjb25uZWN0aW5nIHdhbGxldFxyXG5cclxuICBjb25zdCBjaGVja0lmV2FsbGV0SXNDb25uZWN0ZWQgPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkgcmV0dXJuIFNldEVycm9yKFwicGxlYXNlIGluc3RhbGwgbWV0YW1hc2tcIik7XHJcblxyXG4gICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IHdpbmRvdy5ldGhlcmV1bS5yZXF1ZXN0KHtcclxuICAgICAgbWV0aG9kOiBcImV0aF9hY2NvdW50c1wiLFxyXG4gICAgfSk7XHJcbiAgICBpZiAoYWNjb3VudC5sZW5ndGgpIHtcclxuICAgICAgc2V0Q3VycmVudEFjY291bnQoYWNjb3VudFswXSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGN1cnJlbnRBY2NvdW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIFNldEVycm9yKFwicGxlYXNlIGluc3RhbGwgbWV0YW1hc2sgJiBSZWxvYWRcIik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gY29ubmVjdCB3YWxsZXRcclxuICBjb25zdCBjb25uZWN0V2FsbGV0ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHJldHVybiBTZXRFcnJvcihcInBsZWFzZSBpbnN0YWxsIG1ldGFtYXNrXCIpO1xyXG4gICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IHdpbmRvdy5ldGhlcmV1bS5yZXF1ZXN0KHtcclxuICAgICAgbWV0aG9kOiBcImV0aF9yZXF1ZXN0QWNjb3VudHNcIixcclxuICAgIH0pO1xyXG4gICAgc2V0Q3VycmVudEFjY291bnQoYWNjb3VudFswXSk7XHJcbiAgfTtcclxuXHJcbiAgLy9jcmVhdGUgdm90ZXJzXHJcbiAgY29uc3QgY3JlYXRlVm90ZXIgPSBhc3luYyAoZm9ybUlucHV0LCBmaWxlVVJMLCByb3V0ZXIpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgbmFtZSwgYWRkcmVzcywgcG9zaXRpb24sIHBpbiB9ID0gZm9ybUlucHV0O1xyXG4gICAgICBpZiAoIW5hbWUgfHwgIWFkZHJlc3MgfHwgIXBvc2l0aW9uIHx8ICFwaW4pIHtcclxuICAgICAgICBTZXRFcnJvcihcIklucHV0IGRhdGEgaXMgbWlzc2luZ1wiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy9jb25uZWN0aW5nIHNtYXJ0IGNvbnRyYWN0XHJcbiAgICAgIGNvbnN0IHdlYjNtb2RhbCA9IG5ldyBXZWIzTW9kYWwoKTtcclxuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHdlYjNtb2RhbC5jb25uZWN0KCk7XHJcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5wcm92aWRlcnMuV2ViM1Byb3ZpZGVyKGNvbm5lY3Rpb24pO1xyXG4gICAgICBjb25zdCBzaWduZXIgPSBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgICAgY29uc3QgY29udHJhY3QgPSBmZXRjaENvbnRyYWN0KHNpZ25lcik7XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0geyBuYW1lLCBhZGRyZXNzLCBwb3NpdGlvbiwgaW1hZ2U6IGZpbGVVUkwgfTtcclxuICAgICAgY29uc3QgcGluYXRhVXJsID0gYXdhaXQgdXBsb2FkSlNPTlRvSVBGUyhkYXRhKTtcclxuICAgICAgY29uc3QgaXBmc1VybCA9IEdldElwZnNVcmxGcm9tUGluYXRhKHBpbmF0YVVybC5waW5hdGFVUkwpO1xyXG5cclxuICAgICAgY29uc3Qgdm90ZXIgPSBhd2FpdCBjb250cmFjdC52b3RlclJpZ2h0KGFkZHJlc3MsIG5hbWUsIGZpbGVVUkwsIGlwZnNVcmwpO1xyXG4gICAgICBhd2FpdCB2b3Rlci53YWl0KCk7XHJcblxyXG4gICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjMwMDEvYWRkLXBpblwiLCB7XHJcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBhZGRyZXNzLFxyXG4gICAgICAgICAgcGluLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmVzdWx0ID0gcmVzdWx0Lmpzb24oKTtcclxuICAgICAgY29uc29sZShyZXN1bHQpO1xyXG4gICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgcm91dGVyLnB1c2goXCIvdm90ZXJMaXN0XCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyh2b3Rlcik7XHJcbiAgICAgIHJvdXRlci5wdXNoKFwiL3ZvdGVyTGlzdFwiKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIFNldEVycm9yKFwiRXJyb3IgaW4gY3JlYXRpbmcgdGhlIHZvdGVyXCIpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldEFsbFZvdGVyRGF0YSA9IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHdlYjNtb2RhbCA9IG5ldyBXZWIzTW9kYWwoKTtcclxuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHdlYjNtb2RhbC5jb25uZWN0KCk7XHJcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5wcm92aWRlcnMuV2ViM1Byb3ZpZGVyKGNvbm5lY3Rpb24pO1xyXG4gICAgICBjb25zdCBzaWduZXIgPSBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgICAgY29uc3QgY29udHJhY3QgPSBmZXRjaENvbnRyYWN0KHNpZ25lcik7XHJcblxyXG4gICAgICBjb25zdCB2b3Rlckxpc3REYXRhID0gYXdhaXQgY29udHJhY3QuZ2V0Vm90ZXJMaXN0KCk7XHJcbiAgICAgIHNldFZvdGVyQWRkcmVzcyh2b3Rlckxpc3REYXRhKTtcclxuICAgICAgdm90ZXJMaXN0RGF0YS5tYXAoYXN5bmMgKGVsKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc2luZ2xlVm90ZXJEYXRhID0gYXdhaXQgY29udHJhY3QuZ2V0Vm90ZXJEYXRhKGVsKTtcclxuICAgICAgICBwdXNoVm90ZXJzLnB1c2goc2luZ2xlVm90ZXJEYXRhKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCB2b3Rlckxpc3QgPSBhd2FpdCBjb250cmFjdC5nZXRWb3Rlckxlbmd0aCgpO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyh2b3Rlckxpc3QudG9OdW1iZXIoKSk7XHJcbiAgICAgIHZsZW4gPSB2b3Rlckxpc3QudG9OdW1iZXIoKTtcclxuICAgICAgLy8gY29uc29sZS5sb2codmxlbik7XHJcbiAgICAgIHNldFZvdGVyTGVuZ3RoKHZsZW4pO1xyXG5cclxuICAgICAgLy8gc2V0Vm90ZXJMZW5ndGgodm90ZXJMaXN0LnRvTnVtYmVyKCkpO1xyXG5cclxuICAgICAgY29uc29sZS5sb2codm90ZXJMZW5ndGgpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgU2V0RXJyb3IoXCJTb21ldGhpbmcgd2VudCB3cm9uZyBpbiBmZXRjaGluZyB2b3RlclwiKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBzZXRDYW5kaWRhdGUgPSBhc3luYyAoY2FuZGlkYXRlRm9ybSwgZmlsZVVSTCwgcm91dGVyKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IG5hbWUsIGFkZHJlc3MsIGFnZSB9ID0gY2FuZGlkYXRlRm9ybTtcclxuICAgICAgaWYgKCFuYW1lIHx8ICFhZGRyZXNzIHx8ICFhZ2UpIHtcclxuICAgICAgICBTZXRFcnJvcihcIklucHV0IGRhdGEgaXMgbWlzc2luZ1wiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2cobmFtZSwgYWRkcmVzcywgYWdlLCBmaWxlVVJMKTtcclxuICAgICAgY29uc3Qgd2ViM21vZGFsID0gbmV3IFdlYjNNb2RhbCgpO1xyXG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgd2ViM21vZGFsLmNvbm5lY3QoKTtcclxuICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIoY29ubmVjdGlvbik7XHJcbiAgICAgIGNvbnN0IHNpZ25lciA9IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgICBjb25zdCBjb250cmFjdCA9IGZldGNoQ29udHJhY3Qoc2lnbmVyKTtcclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSB7IG5hbWUsIGFkZHJlc3MsIGFnZSwgaW1hZ2U6IGZpbGVVUkwgfTtcclxuICAgICAgY29uc3QgcGluYXRhVXJsID0gYXdhaXQgdXBsb2FkSlNPTlRvSVBGUyhkYXRhKTtcclxuICAgICAgY29uc3QgaXBmc1VybCA9IEdldElwZnNVcmxGcm9tUGluYXRhKHBpbmF0YVVybC5waW5hdGFVUkwpO1xyXG5cclxuICAgICAgY29uc3QgY2FuZGlkYXRlID0gYXdhaXQgY29udHJhY3Quc2V0Q2FuZGlkYXRlKFxyXG4gICAgICAgIGFkZHJlc3MsXHJcbiAgICAgICAgYWdlLFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgZmlsZVVSTCxcclxuICAgICAgICBpcGZzVXJsXHJcbiAgICAgICk7XHJcbiAgICAgIGF3YWl0IGNhbmRpZGF0ZS53YWl0KCk7XHJcbiAgICAgIC8vIHZlcmlmeUZhY2UoZmlsZVVSTCwgMC43KTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGNhbmRpZGF0ZSk7XHJcbiAgICAgIHJvdXRlci5wdXNoKFwiL1wiKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBnZXROZXdDYW5kaWRhdGUgPSBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB3ZWIzbW9kYWwgPSBuZXcgV2ViM01vZGFsKCk7XHJcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB3ZWIzbW9kYWwuY29ubmVjdCgpO1xyXG4gICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMucHJvdmlkZXJzLldlYjNQcm92aWRlcihjb25uZWN0aW9uKTtcclxuICAgICAgY29uc3Qgc2lnbmVyID0gcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICAgIGNvbnN0IGNvbnRyYWN0ID0gZmV0Y2hDb250cmFjdChzaWduZXIpO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coY29udHJhY3QpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGF3YWl0IGNvbnRyYWN0LmdldENhbmRpZGF0ZXMoKSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGFsbENhbmRpZGF0ZXMgPSBhd2FpdCBjb250cmFjdC5nZXRDYW5kaWRhdGVzKCk7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGFsbENhbmRpZGF0ZXMpO1xyXG4gICAgICBhbGxDYW5kaWRhdGVzLm1hcChhc3luYyAoZWxlKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc2luZ2xlQ2FuZGlkYXRlID0gYXdhaXQgY29udHJhY3QuZ2V0Q2FuZGlkYXRlRGF0YShlbGUpO1xyXG4gICAgICAgIHB1c2hDYW5kaWRhdGUucHVzaChzaW5nbGVDYW5kaWRhdGUpO1xyXG4gICAgICAgIGNhbmRpZGF0ZUluZGV4LnB1c2goc2luZ2xlQ2FuZGlkYXRlWzJdLnRvTnVtYmVyKCkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKHB1c2hDYW5kaWRhdGUpO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhjdXJyZW50QWNjb3VudCk7XHJcblxyXG4gICAgICBjb25zdCBhbGxDYW5kaWRhdGVzTGVuZ3RoID0gYXdhaXQgY29udHJhY3QuZ2V0Q2FuZGlkYXRlTGVuZ3RoKCk7XHJcbiAgICAgIGNsZW4gPSBhbGxDYW5kaWRhdGVzTGVuZ3RoLnRvTnVtYmVyKCk7XHJcbiAgICAgIHNldENhbmRpZGF0ZUxlbmd0aChjbGVuKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIFNldEVycm9yKFwiU29tZXRoaW5nIHdlbnQgd3JvbmcgaW4gZmV0Y2hpbmcgY2FuZGlkYXRlXCIpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgLy8gICBnZXROZXdDYW5kaWRhdGUoKTtcclxuICAvLyB9LCBbXSk7XHJcbiAgLy91cGxvYWQgdG8gaXBmcyB2b3RlciBpbWFnZVxyXG4gIGNvbnN0IGdpdmVWb3RlID0gYXN5bmMgKGlkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjYW5kaWRhdGVBZGRyZXNzID0gaWQuYWRkcmVzcztcclxuICAgICAgY29uc3QgY2FuZGlkYXRlSWQgPSBpZC5pZDtcclxuICAgICAgY29uc3Qgd2ViM21vZGFsID0gbmV3IFdlYjNNb2RhbCgpO1xyXG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgd2ViM21vZGFsLmNvbm5lY3QoKTtcclxuICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIoY29ubmVjdGlvbik7XHJcbiAgICAgIGNvbnN0IHNpZ25lciA9IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgICBjb25zdCBjb250cmFjdCA9IGZldGNoQ29udHJhY3Qoc2lnbmVyKTtcclxuXHJcbiAgICAgIGNvbnN0IHZvdGVyZWRMaXN0ID0gYXdhaXQgY29udHJhY3Qudm90ZShjYW5kaWRhdGVBZGRyZXNzLCBjYW5kaWRhdGVJZCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKHZvdGVyZWRMaXN0KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgU2V0RXJyb3IoXCJFcnJvciBpbiBnaXZpbmcgdm90ZVwiKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHJldHVybiAoXHJcbiAgICA8Vm90aW5nQ29udGV4dC5Qcm92aWRlclxyXG4gICAgICB2YWx1ZT17e1xyXG4gICAgICAgIHZvdGluZ1RpdGxlLFxyXG4gICAgICAgIGNoZWNrSWZXYWxsZXRJc0Nvbm5lY3RlZCxcclxuICAgICAgICBjb25uZWN0V2FsbGV0LFxyXG4gICAgICAgIGNyZWF0ZVZvdGVyLFxyXG4gICAgICAgIGdldEFsbFZvdGVyRGF0YSxcclxuICAgICAgICBnaXZlVm90ZSxcclxuICAgICAgICBzZXRDYW5kaWRhdGUsXHJcbiAgICAgICAgZ2V0TmV3Q2FuZGlkYXRlLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICAgIHZvdGVyQXJyYXksXHJcbiAgICAgICAgdm90ZXJMZW5ndGgsXHJcbiAgICAgICAgdm90ZXJBZGRyZXNzLFxyXG4gICAgICAgIGN1cnJlbnRBY2NvdW50LFxyXG4gICAgICAgIGNhbmRpZGF0ZUxlbmd0aCxcclxuICAgICAgICBjYW5kaWRhdGVBcnJheSxcclxuICAgICAgfX1cclxuICAgID5cclxuICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9Wb3RpbmdDb250ZXh0LlByb3ZpZGVyPlxyXG4gICk7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiV2ViM01vZGFsIiwiZXRoZXJzIiwiYXhpb3MiLCJ1c2VSb3V0ZXIiLCJWb3RpbmdBZGRyZXNzIiwiVm90aW5nQWRkcmVzc0FCSSIsInVwbG9hZEZpbGVUb0lQRlMiLCJ1cGxvYWRKU09OVG9JUEZTIiwiR2V0SXBmc1VybEZyb21QaW5hdGEiLCJmZXRjaENvbnRyYWN0Iiwic2lnbmVyT3JQcm92aWRlciIsIkNvbnRyYWN0IiwiVm90aW5nQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJWb3RpbmdQcm92aWRlciIsImNoaWxkcmVuIiwidm90aW5nVGl0bGUiLCJyb3V0ZXIiLCJ2bGVuIiwiY2xlbiIsImNhIiwiY3VycmVudEFjY291bnQiLCJzZXRDdXJyZW50QWNjb3VudCIsImNhbmRpZGF0ZUxlbmd0aCIsInNldENhbmRpZGF0ZUxlbmd0aCIsInB1c2hDYW5kaWRhdGUiLCJjYW5kaWRhdGVJbmRleCIsImNhbmRpZGF0ZUFycmF5Iiwic2V0Q2FuZGlkYXRlQXJyYXkiLCJlcnJvciIsIlNldEVycm9yIiwiaGlnaGVzdFZvdGUiLCJwdXNoVm90ZXJzIiwidm90ZXJBcnJheSIsInNldFZvdGVyQXJyYXkiLCJ2b3Rlckxlbmd0aCIsInNldFZvdGVyTGVuZ3RoIiwidm90ZXJBZGRyZXNzIiwic2V0Vm90ZXJBZGRyZXNzIiwiZmlsZVVSTCIsInNldEZpbGVVUkwiLCJjaGVja0lmV2FsbGV0SXNDb25uZWN0ZWQiLCJ3aW5kb3ciLCJldGhlcmV1bSIsImFjY291bnQiLCJyZXF1ZXN0IiwibWV0aG9kIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsImNvbm5lY3RXYWxsZXQiLCJjcmVhdGVWb3RlciIsImZvcm1JbnB1dCIsIm5hbWUiLCJhZGRyZXNzIiwicG9zaXRpb24iLCJwaW4iLCJ3ZWIzbW9kYWwiLCJjb25uZWN0aW9uIiwiY29ubmVjdCIsInByb3ZpZGVyIiwicHJvdmlkZXJzIiwiV2ViM1Byb3ZpZGVyIiwic2lnbmVyIiwiZ2V0U2lnbmVyIiwiY29udHJhY3QiLCJkYXRhIiwiaW1hZ2UiLCJwaW5hdGFVcmwiLCJpcGZzVXJsIiwicGluYXRhVVJMIiwidm90ZXIiLCJ2b3RlclJpZ2h0Iiwid2FpdCIsInJlc3VsdCIsImZldGNoIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJoZWFkZXJzIiwianNvbiIsInB1c2giLCJnZXRBbGxWb3RlckRhdGEiLCJ2b3Rlckxpc3REYXRhIiwiZ2V0Vm90ZXJMaXN0IiwibWFwIiwiZWwiLCJzaW5nbGVWb3RlckRhdGEiLCJnZXRWb3RlckRhdGEiLCJ2b3Rlckxpc3QiLCJnZXRWb3Rlckxlbmd0aCIsInRvTnVtYmVyIiwic2V0Q2FuZGlkYXRlIiwiY2FuZGlkYXRlRm9ybSIsImFnZSIsImNhbmRpZGF0ZSIsImdldE5ld0NhbmRpZGF0ZSIsImdldENhbmRpZGF0ZXMiLCJhbGxDYW5kaWRhdGVzIiwiZWxlIiwic2luZ2xlQ2FuZGlkYXRlIiwiZ2V0Q2FuZGlkYXRlRGF0YSIsImFsbENhbmRpZGF0ZXNMZW5ndGgiLCJnZXRDYW5kaWRhdGVMZW5ndGgiLCJnaXZlVm90ZSIsImlkIiwiY2FuZGlkYXRlQWRkcmVzcyIsImNhbmRpZGF0ZUlkIiwidm90ZXJlZExpc3QiLCJ2b3RlIiwiUHJvdmlkZXIiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./context/Voters.js\n"));

/***/ })

});